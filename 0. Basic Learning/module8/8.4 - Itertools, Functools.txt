Генерация комбинаторных объектов itertools
В Питоне есть библиотека itertools, которая содержит много функций для работы с итерируемыми объектами. С этими функциями можно ознакомиться в официальной документации к языку.

Нам наиболее интересны функции, генерирующие комбинаторные объекты.

itertools.combinations(iterable, size) - генерирует все подмножества множества iterable размером size в виде кортежей. Это может быть использовано вместо вложенных циклов при организации перебора. Например, мы можем неэффективно решить задачу о поиске трех чисел в последовательности, дающих наибольшее произведение:

from itertools import combinations

nums = list(map(int, input().split()))
combs = combinations(range(len(nums)), 3)
print(max(map(lambda x: nums[x[0]] * nums[x[1]] * nums[x[2]], combs)))

itertools.permutations(iterable) - генерирует все перестановки iterable. Существует вариант функции с двумя параметрами, второй параметр является размером подмножества. Тогда генерируются все перестановки всех подмножеств заданного размера.

itertools.combinations_with_replacement(iterable, size) - генерирует все подмножества iterable размером size с повторениями, т.е. одно и то же число может входить в подмножество несколько раз.

partial, reduce, accumulate
Модуль functools содержит некоторые функции, которые могут полезны для обработки последовательностей и не только. 

Функция functools.partial предназначена для оборачивания существующих функций с подстановкой некоторых параметров. Например, мы можем создать функцию для печати в файл, чтобы каждый раз не указывать какие-то параметры. Например, существует вариант функции int с двумя параметрами: первый - это переменная, которую необходимо преобразовать в число, а второй - система счисления в которой записано число. С помощью partial мы можем создать функцию-обёртку, преобразующую строки из 0 и 1 в числа:


from functools import partial

binStrToInt = partial(int, base=2)
print(binStrToInt('10010'))

В модуле functools также содержатся функции для обработки последовательностей.

functools.reduce(func, iterable) позволяет применить функцию ко всем элементам последовательности, используя в качестве первого аргумента накопленный результат. Например, если в последовательности были элементы myList = [A, B, C], то результатом применения reduce(f, myList) будет f(f(A, B), C). С помощью reduce, например, можно найти НОД всех чисел в iterable:


from functools import reduce

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

print(reduce(gcd, map(int, input().split())))

itertools.accumulate(iterable, func), которая возвращает iterable со всеми промежуточными значениями, т.е. для списка [A, B, C] accumulate вернет значения A, f(A, B), f(f(A, B), C). Например, можно узнать максимальный элемент для каждого префикса (некоторого количества первых элементов) заданной последовательности:


from itertools import accumulate

print(*accumulate(map(int, input().split()), max))
