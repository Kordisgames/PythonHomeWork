Итераторы и генераторы
В Питоне итераторы - это объекты, которые имеют внутреннее состояние и метод __next__ для перехода к следующему состоянию. Например, можно сконструировать итератор от списка и перебрать все значения: 

myList = [1, 2, 3]
for i in iter(myList):
    print(i)
for i in myList:
    print(i)

В этой программе два цикла эквивалентны.

В Питоне можно создавать и свои итераторы. Их разумно использовать в том случае, если нужно перебрать большое количество значений и существует правило, по которому можно получить следующее значение, однако хранений всех этих значений не имеет смысла, т.к. они пригодятся только один раз.

Для создания итераторов в Питоне используется специальный вид функций, называемых генераторами. В обычной функции return прекращает работу функции. В генераторе вместо return используется оператор yield, который также возвращает значение, но не прекращает выполнение функции, а приостанавливает его до тех пор, пока не потребуется следующее значение итератора. При этом работа функции продолжится с того места и в том состоянии, в котором она находилась на момент вызова yield. Посмотрим, как может быть реализован генератор, аналогичный стандартному range с одним параметром:

def myRange(n):
    i = 0
    while i < n:
        yield i
        i += 1
for i in myRange(10):
    print(i)

Генераторы могут иметь и сложную рекурсивную структуру. Например, мы можем написать генератор, который будет выдавать все числа заданной длины, цифры в которых не убывают и старшая цифра не превосходит заданного параметра:

def genDecDigs(cntDigits, maxDigit):
    if cntDigits > 0:
        for nowDigit in range(maxDigit + 1):
            for tail in genDecDigs(cntDigits - 1, nowDigit):
                yield nowDigit * 10**(cntDigits - 1) + tail
    else:
        yield 0
            
print(*genDecDigs(2, 3))  

Вывод этой программы будет выглядеть так: 0 10 11 20 21 22 30 31 32 33

В этой программе рекурсивный генератор перебирал все допустимые цифры в качестве той, которая должна стоять на заданной позиции и генерировал все возможные последующие цифры.

Также в этой программе мы использовали одну особенность функции print: если переди именем iterable (а результат, возвращаемый генератором является iterable) поставить *, то будут напечатны все значения через пробел.

Результат работы генератора можно сохранить, например, в список с помощью функции list, как мы уже делали это с результатом работы range.