**Наследование и полиморфизм**
Операции сложения и умножения на вещественное или целое число для комплексных чисел очень похожи на поведение свободных векторов на плоскости. Они соответствуют сложению векторов или умножение вектора на число, где действительная часть комплексного числа является x-координатой вектора, а мнимая - y-координатой. 

Кроме того, свободный вектор обладает некоторыми операциями, которые характерны только для него, но не для вещественного числа. Например, это может быть метод length, вычисляющий длину вектора. Нам не хотелось бы засорять код для описания комплексного числа методами для работы со свободным вектором, но с другой стороны не хотелось бы заново переписывать методы сложения и умножения для свободных векторов.

В такой ситуации разумно создать новый класс для описания свободного вектора (или точки на плоскости, что то же самое), который унаследовал бы все методы комплексных чисел и добавил бы новый метод length.

Мы уже знаем, что для того, чтобы пронаследовать класс от другого достаточно в описании класса указать в круглых скобках, от кого он наследуется. Таким образом, мы можем записать наше описание класса Point с определенным методом length так:

	class ComplexError(BaseException):
    def __init__(self, Complex, other):
        self.arg1 = Complex
        self.arg2 = other

	class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep
    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)
    def __mul__(self, other):
        if isinstance(other, Complex):
            newRe = self.re * other.re - self.im * other.im
            newIm = self.re * other.im + self.re * other.im
        elif isinstance(other, int) or isinstance(other, float):
            newRe = self.re * other
            newIm = self.im * other
        else:
            raise ComplexError(self, other)
        return Complex(newRe, newIm)
    __rmul__ = __mul__

	class Point(Complex):
    def length(self):
        return (self.re**2 + self.im**2)**(1/2)

	a = Point(3, 4)
		b = Complex(1, 2)
	print(a.length())
	c = a + b
	print(c)

Вывод этой программы будет 

	5.0
	4+6i

Здесь мы не только убедились в том, что свежесозданный метод работает, но и сделали довольно странную вещь: сложили точку на плоскости с комплексным числом. Дело в том, что объекта класса Point также одновременно является и объектом типа Complex, т.к. Point пронаследован от Complex. Point лишь расширяет и дополняет Complex, а значит Point может смело быть интерпретирован как Complex, но не наоброт.

В этом примере будут истинны выражения isinstance(a, Point) и isinstance(a, Complex), но будет ложно выражение isinstance(b, Point).

Переопределение методов
Если мы попытаемся напечатать объект типа Point, то он напечатается как комплексное число. Нам хотелось бы, чтобы точки на плоскости печатались в виде (x, y), а не x+yi.

В языке Питон любой метод можно переопределить в наследнике, что мы и сделаем для метода ____str____ для класса Point:

	class ComplexError(BaseException):
    def __init__(self, Complex, other):
        self.arg1 = Complex
        self.arg2 = other

		class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep
    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)
    def __mul__(self, other):
        if isinstance(other, Complex):
            newRe = self.re * other.re - self.im * other.im
            newIm = self.re * other.im + self.re * other.im
        elif isinstance(other, int) or isinstance(other, float):
            newRe = self.re * other
            newIm = self.im * other
        else:
            raise ComplexError(self, other)
        return Complex(newRe, newIm)
    __rmul__ = __mul__

	class Point(Complex):
    def length(self):
        return (self.re**2 + self.im**2)**(1/2)
    def __str__(self):
        return str((self.re, self.im))

	a = Point(3, 4)
	print(a)

Наш метод обязан возвращать строку, но мы можем воспользоваться функцией str от кортежа, которая выдаст нам нужный результат. 

Проектирование структуры классов
Структура описания классов представляет собой дерево (на самом деле в Питоне - ациклический граф), пронаследованный от единого корня - базового пустого класса.

С помощью грамотно спроектированной структуры классов можно добиться легкой читаемости и максимального повторного использования кода, обеспечения единого интерфейса и множество других радостей.

Однако, внесение фичи или изменение на высоком уровне иерархии классов может привести к необходимости выполнить огромное количество работы по модификации всех потомков этого класса, а также к полной несовместимости с предыдущей версией. Многочисленные изменения такого рода приводят к уродливым конструкциям, которые невозможно понимать и отлаживать.

В то же время, закладывание перспективных фичей в структуру классов ведет к переусложнению и сводит на нет все повторное использование кода за счет громоздкости конструкций. Кроме того, перспективные фичи могут быть недостаточно обдуманы и приведут к еще большему уродству, когда дело дойдет до их реальной реализации (если дойдет).

Таким образом, грамотное проектирование системы классов требует не только хорошего знания паттернов проектирования, но и большого практического опыта. На начальном этапе стоит обучаться проектированию систем, в которые не планируется внесение изменений.