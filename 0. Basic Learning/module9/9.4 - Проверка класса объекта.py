Проверка класса объекта
Переопределим для комплексных чисел ещё одну операцию - умножение. При этом мы хотим уметь умножать комплексные числа как на целые или действительные, так и на другие комплексные числа. 

При умножении комплексного числа вида a+b * i$на целое или вещественное число x результатом будет комплексное число a * x + b * x * b.

Переменожение двух комплексных чисел производится аналогично умножению двух многочленов первой степени:

(a + b * i) * (c + d * i) = a * c + (a * d + b * c) * i + b * d * i**2

Мы знаем, что i**2 = -1. Значит окончательно результат умножения будет выглядеть так: 

a * c - b * d + (a * d + b * c) * i

Нам осталось понять, как определить, передано ли в наш метод комплексное или не комплексное число. 

В языке Питон существует функция isinstance, которая в качестве первого параметра принимает объект, а в качестве второго - название класса. Она возвращает истину, если объект относится к данному классу и ложь в противном случае. Эта функция позволит нам добиться нужной функциональности от метода __mul__, умножающего числа.


class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep
    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)
    def __mul__(self, other):
        if isinstance(other, Complex):
            newRe = self.re * other.re - self.im * other.im
            newIm = self.re * other.im + self.im * other.re
        elif isinstance(other, int) or isinstance(other, float):
            newRe = self.re * other
            newIm = self.im * other
        return Complex(newRe, newIm)
    __rmul__ = __mul__
        
a = Complex(1, 2)
b = Complex(3, -4.5)
print(a * b)
print(a * 2)

Кроме добавленного метода __mul__ внимания также заслуживает строка __rmul__ = __mul__. Это присваивание одного метода (функции) другому, т.е. при вызове метода __rmul__ будет вызываться тот же самый метод __mul__. 

В языке питон операция a * b  заменяется на вызов метода a.__mul__(b). Если a было комплексным числом, а b - вещественным, то вызовется метод __mul__ для объекта a нашего класса Complex.

Однако, если a было вещественным числом, а b - комлексным, то произойдет попытка вызвать метод __mul__ для объекта класса float. Естественно, разработчики стандартной библиотеки языка Питон не могли предположить, что вы когда-нибудь напишите класс Complex и будете пытаться умножить на него вещественное число, поэтому метод __mul__, где в качестве параметра передается нечто неизвестное, будет заканчивать свою работу с ошибкой. Чтобы избежать таких ситуаций в языке Питон после неудачной попытки совершить a.__mul__(b) просходит попытка совершить действие b.__rmul__(a) и в нашем случае она заканчивается успехом.