Встроенные функции для работы с последовательностями
В языке Питон есть много функций, которые принимают в качестве параметра iterable и могут сделать что-то полезное. С некоторыми из них, такими как sorted или map мы уже немного знакомы. Рассмотрим еще некоторые из них: 

sum - находит сумму всех элементов iterable.

min, max - находит минимум и максимум в последовательности iterable.

map - умеет принимать более двух параметров. Например, такая запись map(f, iterA, iterB) вернет iterable со значениями f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), ...

filter(predicate, iterable) - применяет функцию predicate ко всем элементам iterable и возвращает iterable, который содержит только те элементы, которые удовлетворяли предикаты (т.е. функция predicate вернула True). Например, так может выглядеть решение задачи о поиске минимального положительного элемента в списке:

print(min(filter(lambda x: x > 0, map(int, input().split()))))

Здесь в качестве предиката использована лямбда-функция, которая возвращает True при значении параметра больше 0, а в качестве входного iterable - результат вызова map для функции int и нарезанного на слова ввода. Функция min применена к тому iterable, который был возвращен функцией filter.

enumerate - возвращает кортежи из номера элемента (при нумерации с нуля) и значения очередного элемента. С помощью enumerate, например, удобно перебирать элементы iterable (доступ по индексу в которых невозможен) и выводить номера элементов, которые обладают некоторым свойством:


f = open('data.txt', 'r', encoding='utf8')
for i, line in enumerate(f):
    if line.strip() == '':
        print('Blank line at line', i)

any, all - возвращают истину, если хотя бы один или все элементы iterable истинны соответственно. Например, так можно проверить, не превышают ли все члены последовательности 100 по модулю:


print(all(map(lambda x: abs(int(x)) <= 100, input().split())))

zip(iterA, iterB, ...) - конструирует кортежи из элементов (iterA[0], iterB[0], ...), (iterA[1], iterB[1], ...), ...