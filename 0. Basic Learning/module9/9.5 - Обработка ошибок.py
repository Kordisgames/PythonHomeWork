Обработка ошибок
Время от времени в программах возникают ошибочные ситуации, которые не могут быть обработаны в том месте, где возникла ошибка, а должны быть обработаны тем или иным образом в более внешней части программы. 

Например, если на этапе выполнения промежуточной логики обнаружилось, что вы пытаетесь записать строку в то, что должно быть числом, то вы ничего не можете с этим сделать. В таком случае нужно вываливаться из стека вызовов функций или методов промежуточной логики до тех пор, пока мы не дойдем до фронтенда, который сообщит пользователю о том, что он ввел недопустимое значение и попросит, например, ввести его заново.

Наверняка вы сталкивались с ситуацией заполнения огромной формы, попытка отправить которую приводила к тому, что появлялось окошко со словом "ошибка" без каких-либо уточнений. Это плохой стиль, сообщение об ошибке должно быть информативным, чтобы позволить быстро её найти и исправить. Таким образом, при создании ошибки нужно передавать исчерпывающую информацию о ней.

В нашем примере с вещественными числами мы можем рассмотреть такой пример ошибки: умножение комплексного числа на что-то, отличное от целого, вещественного или комплексного числа. Когда мы дошли до этапа умножения - мы уже ничего не можем предпринять для исправления этой ошибки, кроме как просигнализировать о ней в то место, откуда была вызвана наша операция умножения.

При этом на этапе вызова операции умножения мы уже можем предпринять какие-то действия. Например, сообщить пользователю о том, какую фигню он ввел и попросить ввести все-таки комплексное число. Или, если мы обрабатываем последовательность, из которой нужно вычленить и перемножить комплексные числа - просто перейти к следующему элементу последовательности. На этапе когда мы дошли до неудачного выполнения операция умножения мы не знаем и не можем знать как должна себя вести конкретная программа при возникновении такой ошибки.

Когда мы дойдем до ошибочной операции мы можем сконструировать специальный класс, содержащий подробное описание ошибки и выбросить его в то место, которое способно его обработать.

Выбрасывается ошибка с помощью команды raise, а ловится блоком try-except. Для случая умножения комплексного числа на мусор мы можем сконструировать класс ошибки, содержащий в себе ссылку как на комплексное число, так и на второй аргумент метода умножения.

Класс для ошибки должен быть наследником стандартного класса BaseException. Пока для нас это значит только то, что при создании описания класса ошибки мы должны написать в скобках после его названия BaseException. Потенциально ошибочные действия должны выполняться в блоке try, а команды для обработки ошибки должны быть в блоке except. Пример с обработкой ошибки будет выглядеть так:


class ComplexError(BaseException):
    def __init__(self, Complex, other):
        self.arg1 = Complex
        self.arg2 = other

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep
    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)
    def __mul__(self, other):
        if isinstance(other, Complex):
            newRe = self.re * other.re - self.im * other.im
            newIm = self.re * other.im + self.im * other.re
        elif isinstance(other, int) or isinstance(other, float):
            newRe = self.re * other
            newIm = self.im * other
        else:
            raise ComplexError(self, other)
        return Complex(newRe, newIm)
    __rmul__ = __mul__

a = Complex(1, 2)        
try:
    res = a * 'abcd'
except ComplexError as ce:
    print('Error in mul with args:', ce.arg1, ce.arg2)

Вывод этой программы будет:

Error in mul with args: 1+2i abcd

По нему легко понять, что ошибка возникает при операции умножения и увидеть, что было передано в неё в качестве аргументов.

После команды except мы можем указать имя класса ошибки, который он должен обрабатывать, затем написать ''as'' и указать имя переменной, в которую попадет объект с описанием конкретной ошибки.

Блоков except может быть несколько для обработки ошибок разных типов. Проверки выполняются последовательно, будет выполнен тот блок команд, у которого имя класса совпадает с именем класса ошибки или является его предком в дереве иерархии наследования.