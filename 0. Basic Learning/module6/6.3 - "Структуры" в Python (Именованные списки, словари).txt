Для хранения сложных записей во многих языках есть специальные типы данных, такие как struct в C++ или record в Паскале.

Переменная типа структура содержит в себе несколько именованных полей. Например, возвращаясь к задаче сортировки людей по убыванию роста, нам было бы удобно хранить описание каждого человека в виде структуры с двумя полями: ростом и именем.

В чистом виде типа данных "структура" в стандарте языка Питон нет. Есть несколько способов реализации аналога структур: namedtuple из библиотеки collections, использование словарей (будет рассмотрено в следующих лекциях) или использование классов в качестве структур. Рассмотрим на примере последний способ.

Напомним условие задачи: людей нужно упорядочить по убыванию роста, но в случае одинакового роста они должны быть упорядочены по фамилии. Решение с использованием классов в качестве структур будет выглядеть так:

class Man:
    height = 0
    name = ''

def manKey(man):
    return (-man.height, man.name)

n = int(input())
peopleList = []
for i in range(n):
    tempManData = input().split()
    man = Man()
    man.height = int(tempManData[0])
    man.name = tempManData[1]
    peopleList.append(man)
peopleList.sort(key=manKey)
for man in peopleList:
    print(man.height, man.name)

Для того чтобы пользоваться классами как структурами мы создаем новый тип данных Man. В описании класса мы перечисляем имена всех полей и их значения по-умолчанию.

В дальнейшем мы можем создавать объекты класса Man (это делается строкой man = Man()), которые сначала проинициализируют свои поля значениями по умолчанию. Доступ к полям класса осуществляется через точку.

Функция сравнения принимает объект класса и генерирует ключ, по которому эти объекты будут сравниваться при сортировке.

Использование структур для описания сложных объектов намного предпочтительнее, чем использование кортежей. При количестве параметров больше двух использование кортежей запутывает читателя и писателя кода, т.к. совершенно невозможно понять что хранится в badNamedTuple[13] и легко понять что хранится в goodNamedStruct.goodNamedField.